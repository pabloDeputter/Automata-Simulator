<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Transitional//EN" "https://www.w3.org/TR/xhtml1/DTD/xhtml1-transitional.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta http-equiv="Content-Type" content="text/xhtml;charset=UTF-8"/>
<meta http-equiv="X-UA-Compatible" content="IE=9"/>
<meta name="generator" content="Doxygen 1.9.1"/>
<meta name="viewport" content="width=device-width, initial-scale=1"/>
<title>My Project: Utils Namespace Reference</title>
<link href="tabs.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="jquery.js"></script>
<script type="text/javascript" src="dynsections.js"></script>
<link href="search/search.css" rel="stylesheet" type="text/css"/>
<script type="text/javascript" src="search/searchdata.js"></script>
<script type="text/javascript" src="search/search.js"></script>
<link href="doxygen.css" rel="stylesheet" type="text/css" />
</head>
<body>
<div id="top"><!-- do not remove this div, it is closed by doxygen! -->
<div id="titlearea">
<table cellspacing="0" cellpadding="0">
 <tbody>
 <tr style="height: 56px;">
  <td id="projectalign" style="padding-left: 0.5em;">
   <div id="projectname">My Project
   </div>
  </td>
 </tr>
 </tbody>
</table>
</div>
<!-- end header part -->
<!-- Generated by Doxygen 1.9.1 -->
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
var searchBox = new SearchBox("searchBox", "search",false,'Search','.html');
/* @license-end */
</script>
<script type="text/javascript" src="menudata.js"></script>
<script type="text/javascript" src="menu.js"></script>
<script type="text/javascript">
/* @license magnet:?xt=urn:btih:cf05388f2679ee054f2beb29a391d25f4e673ac3&amp;dn=gpl-2.0.txt GPL-v2 */
$(function() {
  initMenu('',true,false,'search.php','Search');
  $(document).ready(function() { init_search(); });
});
/* @license-end */</script>
<div id="main-nav"></div>
<!-- window showing the filter options -->
<div id="MSearchSelectWindow"
     onmouseover="return searchBox.OnSearchSelectShow()"
     onmouseout="return searchBox.OnSearchSelectHide()"
     onkeydown="return searchBox.OnSearchSelectKey(event)">
</div>

<!-- iframe showing the search results (closed by default) -->
<div id="MSearchResultsWindow">
<iframe src="javascript:void(0)" frameborder="0" 
        name="MSearchResults" id="MSearchResults">
</iframe>
</div>

</div><!-- top -->
<div class="header">
  <div class="summary">
<a href="#func-members">Functions</a>  </div>
  <div class="headertitle">
<div class="title">Utils Namespace Reference</div>  </div>
</div><!--header-->
<div class="contents">

<p>Methods used for the algorithms.  
<a href="namespace_utils.html#details">More...</a></p>
<table class="memberdecls">
<tr class="heading"><td colspan="2"><h2 class="groupheader"><a name="func-members"></a>
Functions</h2></td></tr>
<tr class="memitem:acabd5d15d1c38363e4668684990adeb8"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#acabd5d15d1c38363e4668684990adeb8">bool_to_string</a> (bool x)</td></tr>
<tr class="memdesc:acabd5d15d1c38363e4668684990adeb8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Converts bool to string.  <a href="namespace_utils.html#acabd5d15d1c38363e4668684990adeb8">More...</a><br /></td></tr>
<tr class="separator:acabd5d15d1c38363e4668684990adeb8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ab92c3a346f599ff6a780fea76a3dc7ff"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#ab92c3a346f599ff6a780fea76a3dc7ff">parse_set</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:ab92c3a346f599ff6a780fea76a3dc7ff"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse set into a vector of string - {p_1,p_2,p_3} --&gt; [p_1, p_2, p_3].  <a href="namespace_utils.html#ab92c3a346f599ff6a780fea76a3dc7ff">More...</a><br /></td></tr>
<tr class="separator:ab92c3a346f599ff6a780fea76a3dc7ff"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adcabc18dc019165483f4760ed0ccb9a8"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::string &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#adcabc18dc019165483f4760ed0ccb9a8">parse_set_space</a> (const std::string &amp;x)</td></tr>
<tr class="memdesc:adcabc18dc019165483f4760ed0ccb9a8"><td class="mdescLeft">&#160;</td><td class="mdescRight">Parse set into a vector of string, but elements of set are spaced out with spaces - {p_1, p_2, p_3} --&gt; [p_1, p_2, p_3].  <a href="namespace_utils.html#adcabc18dc019165483f4760ed0ccb9a8">More...</a><br /></td></tr>
<tr class="separator:adcabc18dc019165483f4760ed0ccb9a8"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a58b9c27809dc16d01a31273c3177599b"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a58b9c27809dc16d01a31273c3177599b">make_set</a> (const std::vector&lt; std::string &gt; &amp;x)</td></tr>
<tr class="memdesc:a58b9c27809dc16d01a31273c3177599b"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make set out of vector of strings.  <a href="namespace_utils.html#a58b9c27809dc16d01a31273c3177599b">More...</a><br /></td></tr>
<tr class="separator:a58b9c27809dc16d01a31273c3177599b"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a406ded8cfaeb8e1751967b4824ac77fd"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a406ded8cfaeb8e1751967b4824ac77fd">make_new_states</a> (std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;pairs, std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;new_states)</td></tr>
<tr class="memdesc:a406ded8cfaeb8e1751967b4824ac77fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make new states from the result of the TFA.  <a href="namespace_utils.html#a406ded8cfaeb8e1751967b4824ac77fd">More...</a><br /></td></tr>
<tr class="separator:a406ded8cfaeb8e1751967b4824ac77fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a091998c9a37b5e1e4f091ea405842760"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a091998c9a37b5e1e4f091ea405842760">replace_states</a> (<a class="el" href="class_d_f_a.html">DFA</a> *old_dfa, <a class="el" href="class_d_f_a.html">DFA</a> &amp;minimized_dfa)</td></tr>
<tr class="memdesc:a091998c9a37b5e1e4f091ea405842760"><td class="mdescLeft">&#160;</td><td class="mdescRight">Replace states of old <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> by newly created states from minimized <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a>, old <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> is only used for recognizing the states.  <a href="namespace_utils.html#a091998c9a37b5e1e4f091ea405842760">More...</a><br /></td></tr>
<tr class="separator:a091998c9a37b5e1e4f091ea405842760"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a6870b41572144413b86ce3ac3b4bf78e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; const <a class="el" href="class_state.html">State</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a6870b41572144413b86ce3ac3b4bf78e">state_closure</a> (const std::string &amp;set, const std::string &amp;symbol, <a class="el" href="class_d_f_a.html">DFA</a> *dfa)</td></tr>
<tr class="memdesc:a6870b41572144413b86ce3ac3b4bf78e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get "closure" of a set, calculates all the transitions to states for a specific input-symbol for a set.  <a href="namespace_utils.html#a6870b41572144413b86ce3ac3b4bf78e">More...</a><br /></td></tr>
<tr class="separator:a6870b41572144413b86ce3ac3b4bf78e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a8b6311e76aebea6708a1026e4d3f21f7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a8b6311e76aebea6708a1026e4d3f21f7">merge_duplicates</a> (const std::string &amp;state_name, std::vector&lt; std::string &gt; &amp;to_merge, std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;states)</td></tr>
<tr class="memdesc:a8b6311e76aebea6708a1026e4d3f21f7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Merge / Delete states of given <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a>.  <a href="namespace_utils.html#a8b6311e76aebea6708a1026e4d3f21f7">More...</a><br /></td></tr>
<tr class="separator:a8b6311e76aebea6708a1026e4d3f21f7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ac51843a4d3fa4abfb951131cc4532161"><td class="memItemLeft" align="right" valign="top">std::tuple&lt; std::string, bool, bool &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#ac51843a4d3fa4abfb951131cc4532161">make_new_state</a> (const std::vector&lt; std::string &gt; &amp;parsed_set, const <a class="el" href="class_d_f_a.html">DFA</a> *dfa)</td></tr>
<tr class="memdesc:ac51843a4d3fa4abfb951131cc4532161"><td class="mdescLeft">&#160;</td><td class="mdescRight">Make a new set from a parsed set.  <a href="namespace_utils.html#ac51843a4d3fa4abfb951131cc4532161">More...</a><br /></td></tr>
<tr class="separator:ac51843a4d3fa4abfb951131cc4532161"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a64f005181c2e7dd842c21ee3826a6b93"><td class="memItemLeft" align="right" valign="top">std::string&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a64f005181c2e7dd842c21ee3826a6b93">exist_set</a> (const std::map&lt; const std::string, <a class="el" href="class_state.html">State</a> * &gt; &amp;states, const std::string &amp;set)</td></tr>
<tr class="memdesc:a64f005181c2e7dd842c21ee3826a6b93"><td class="mdescLeft">&#160;</td><td class="mdescRight">Checks if a set already exists.  <a href="namespace_utils.html#a64f005181c2e7dd842c21ee3826a6b93">More...</a><br /></td></tr>
<tr class="separator:a64f005181c2e7dd842c21ee3826a6b93"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a46e7afd21ad2324eabfc7738d1d8dda9"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a46e7afd21ad2324eabfc7738d1d8dda9">mark_accepting</a> (std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;pairs)</td></tr>
<tr class="memdesc:a46e7afd21ad2324eabfc7738d1d8dda9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks all the pairs with at least 1 accepting state, distinguishable states.  <a href="namespace_utils.html#a46e7afd21ad2324eabfc7738d1d8dda9">More...</a><br /></td></tr>
<tr class="separator:a46e7afd21ad2324eabfc7738d1d8dda9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:aa161e077bf3e4adbbd2bdf6baff2039d"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_pair.html">Pair</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#aa161e077bf3e4adbbd2bdf6baff2039d">get_marked</a> (std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;pairs)</td></tr>
<tr class="memdesc:aa161e077bf3e4adbbd2bdf6baff2039d"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the marked pairs.  <a href="namespace_utils.html#aa161e077bf3e4adbbd2bdf6baff2039d">More...</a><br /></td></tr>
<tr class="separator:aa161e077bf3e4adbbd2bdf6baff2039d"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ae43845525c034497cc0789a7f89e853e"><td class="memItemLeft" align="right" valign="top">std::vector&lt; <a class="el" href="class_pair.html">Pair</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#ae43845525c034497cc0789a7f89e853e">get_unmarked</a> (std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;pairs)</td></tr>
<tr class="memdesc:ae43845525c034497cc0789a7f89e853e"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get all the unmarked pairs.  <a href="namespace_utils.html#ae43845525c034497cc0789a7f89e853e">More...</a><br /></td></tr>
<tr class="separator:ae43845525c034497cc0789a7f89e853e"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adf82d5e1f9cfdeff74f3c1fddc850e53"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#adf82d5e1f9cfdeff74f3c1fddc850e53">mark_all</a> (std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;pairs, <a class="el" href="class_d_f_a.html">DFA</a> *dfa)</td></tr>
<tr class="memdesc:adf82d5e1f9cfdeff74f3c1fddc850e53"><td class="mdescLeft">&#160;</td><td class="mdescRight">Executes the recursive step of the TFA until there are no more distinguishable pairs left to mark.  <a href="namespace_utils.html#adf82d5e1f9cfdeff74f3c1fddc850e53">More...</a><br /></td></tr>
<tr class="separator:adf82d5e1f9cfdeff74f3c1fddc850e53"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:ad4b8a27843af57e691f3ae7ddd673ee7"><td class="memItemLeft" align="right" valign="top">void&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#ad4b8a27843af57e691f3ae7ddd673ee7">mark_pairs</a> (const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;to_mark, std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;pairs)</td></tr>
<tr class="memdesc:ad4b8a27843af57e691f3ae7ddd673ee7"><td class="mdescLeft">&#160;</td><td class="mdescRight">Marks all the given pairs.  <a href="namespace_utils.html#ad4b8a27843af57e691f3ae7ddd673ee7">More...</a><br /></td></tr>
<tr class="separator:ad4b8a27843af57e691f3ae7ddd673ee7"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:adc301e171b922efd0efb995488c151c9"><td class="memItemLeft" align="right" valign="top">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#adc301e171b922efd0efb995488c151c9">get_states_to</a> (const <a class="el" href="class_pair.html">Pair</a> &amp;pair, const std::string &amp;symbol, <a class="el" href="class_d_f_a.html">DFA</a> *dfa)</td></tr>
<tr class="memdesc:adc301e171b922efd0efb995488c151c9"><td class="mdescLeft">&#160;</td><td class="mdescRight">Get states that go to a pair of states on a specific input-symbol(=look in table and search for the names of the states of the given pair)  <a href="namespace_utils.html#adc301e171b922efd0efb995488c151c9">More...</a><br /></td></tr>
<tr class="separator:adc301e171b922efd0efb995488c151c9"><td class="memSeparator" colspan="2">&#160;</td></tr>
<tr class="memitem:a2d9a39a3b099abb7b3e270dbedd682fd"><td class="memItemLeft" align="right" valign="top">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt;&#160;</td><td class="memItemRight" valign="bottom"><a class="el" href="namespace_utils.html#a2d9a39a3b099abb7b3e270dbedd682fd">minimize_</a> (<a class="el" href="class_d_f_a.html">DFA</a> *dfa)</td></tr>
<tr class="memdesc:a2d9a39a3b099abb7b3e270dbedd682fd"><td class="mdescLeft">&#160;</td><td class="mdescRight">"Activation" method for the TFA  <a href="namespace_utils.html#a2d9a39a3b099abb7b3e270dbedd682fd">More...</a><br /></td></tr>
<tr class="separator:a2d9a39a3b099abb7b3e270dbedd682fd"><td class="memSeparator" colspan="2">&#160;</td></tr>
</table>
<a name="details" id="details"></a><h2 class="groupheader">Detailed Description</h2>
<div class="textblock"><p>Methods used for the algorithms. </p>
</div><h2 class="groupheader">Function Documentation</h2>
<a id="acabd5d15d1c38363e4668684990adeb8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#acabd5d15d1c38363e4668684990adeb8">&#9670;&nbsp;</a></span>bool_to_string()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utils::bool_to_string </td>
          <td>(</td>
          <td class="paramtype">bool&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Converts bool to string. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Input bool </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Return bool as string </dd></dl>

</div>
</div>
<a id="a64f005181c2e7dd842c21ee3826a6b93"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a64f005181c2e7dd842c21ee3826a6b93">&#9670;&nbsp;</a></span>exist_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utils::exist_set </td>
          <td>(</td>
          <td class="paramtype">const std::map&lt; const std::string, <a class="el" href="class_state.html">State</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>states</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>set</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Checks if a set already exists. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">states</td><td>Map with the existing states and given names </td></tr>
    <tr><td class="paramname">set</td><td>Set containing the name of the states as string </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns the name of the state if it already exists, else "/" </dd></dl>

</div>
</div>
<a id="aa161e077bf3e4adbbd2bdf6baff2039d"></a>
<h2 class="memtitle"><span class="permalink"><a href="#aa161e077bf3e4adbbd2bdf6baff2039d">&#9670;&nbsp;</a></span>get_marked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_pair.html">Pair</a> * &gt; Utils::get_marked </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the marked pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in TFA with the name of the pair as key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of pointers to marked pairs </dd></dl>

</div>
</div>
<a id="adc301e171b922efd0efb995488c151c9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adc301e171b922efd0efb995488c151c9">&#9670;&nbsp;</a></span>get_states_to()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::pair&lt; std::string, std::string &gt; &gt; Utils::get_states_to </td>
          <td>(</td>
          <td class="paramtype">const <a class="el" href="class_pair.html">Pair</a> &amp;&#160;</td>
          <td class="paramname"><em>pair</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_a.html">DFA</a> *&#160;</td>
          <td class="paramname"><em>dfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get states that go to a pair of states on a specific input-symbol(=look in table and search for the names of the states of the given pair) </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pair</td><td>The pair which shall be searched for </td></tr>
    <tr><td class="paramname">symbol</td><td>The current input-symbol </td></tr>
    <tr><td class="paramname">dfa</td><td>Pointer to <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> where the TFA is executed on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of pairs of strings containing the name of state_1 and state_2 of a pair </dd></dl>

</div>
</div>
<a id="ae43845525c034497cc0789a7f89e853e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ae43845525c034497cc0789a7f89e853e">&#9670;&nbsp;</a></span>get_unmarked()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; <a class="el" href="class_pair.html">Pair</a> * &gt; Utils::get_unmarked </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get all the unmarked pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in the TFA with the name of the pair as key </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of pointer to unmarked pairs </dd></dl>

</div>
</div>
<a id="ac51843a4d3fa4abfb951131cc4532161"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ac51843a4d3fa4abfb951131cc4532161">&#9670;&nbsp;</a></span>make_new_state()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::tuple&lt; std::string, bool, bool &gt; Utils::make_new_state </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>parsed_set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const <a class="el" href="class_d_f_a.html">DFA</a> *&#160;</td>
          <td class="paramname"><em>dfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make a new set from a parsed set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">parsed_set</td><td>Vector of strings containing the name of states of set </td></tr>
    <tr><td class="paramname">dfa</td><td>The <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> / <a class="el" href="class_n_f_a.html" title="Class implemented for NFA that inherits of DFA, because NFA doesn&#39;t needs to be working for implement...">NFA</a> with the original states inside the parsed_set, used to check if these are accepting or starting </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Returns a tuple with the name of the new state - string, starting - bool and accepting - bool in respective order </dd></dl>

</div>
</div>
<a id="a406ded8cfaeb8e1751967b4824ac77fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a406ded8cfaeb8e1751967b4824ac77fd">&#9670;&nbsp;</a></span>make_new_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::make_new_states </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>new_states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make new states from the result of the TFA. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in TFA with the name of the pair as key, indistinguishable pairs are unmarked </td></tr>
    <tr><td class="paramname">new_states</td><td>Most of the times a vector containing vector of strings referenced </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a58b9c27809dc16d01a31273c3177599b"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a58b9c27809dc16d01a31273c3177599b">&#9670;&nbsp;</a></span>make_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::string Utils::make_set </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Make set out of vector of strings. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Vector of string containing the name of states </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Set containing name of states </dd></dl>

</div>
</div>
<a id="a46e7afd21ad2324eabfc7738d1d8dda9"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a46e7afd21ad2324eabfc7738d1d8dda9">&#9670;&nbsp;</a></span>mark_accepting()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::mark_accepting </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks all the pairs with at least 1 accepting state, distinguishable states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in TFA with the name of the pair as key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="adf82d5e1f9cfdeff74f3c1fddc850e53"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adf82d5e1f9cfdeff74f3c1fddc850e53">&#9670;&nbsp;</a></span>mark_all()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::mark_all </td>
          <td>(</td>
          <td class="paramtype">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_a.html">DFA</a> *&#160;</td>
          <td class="paramname"><em>dfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Executes the recursive step of the TFA until there are no more distinguishable pairs left to mark. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">pairs</td><td>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in the TFA with the name of the pair as key </td></tr>
    <tr><td class="paramname">dfa</td><td>Pointer to <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> where the TFA is executed on </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="ad4b8a27843af57e691f3ae7ddd673ee7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ad4b8a27843af57e691f3ae7ddd673ee7">&#9670;&nbsp;</a></span>mark_pairs()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::mark_pairs </td>
          <td>(</td>
          <td class="paramtype">const std::vector&lt; std::pair&lt; std::string, std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>to_mark</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; &amp;&#160;</td>
          <td class="paramname"><em>pairs</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Marks all the given pairs. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">to_mark</td><td>Vector of pairs of strings containing the name of state_1 and state_2 of a pair </td></tr>
    <tr><td class="paramname">pairs</td><td>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in the TFA with the name of the pair as key </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a8b6311e76aebea6708a1026e4d3f21f7"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a8b6311e76aebea6708a1026e4d3f21f7">&#9670;&nbsp;</a></span>merge_duplicates()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::merge_duplicates </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>state_name</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::string &gt; &amp;&#160;</td>
          <td class="paramname"><em>to_merge</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">std::vector&lt; std::vector&lt; std::string &gt;&gt; &amp;&#160;</td>
          <td class="paramname"><em>states</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Merge / Delete states of given <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a>. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">state_name</td><td>Name of state to merge / delete </td></tr>
    <tr><td class="paramname">to_merge</td><td>Vector of strings where the state_name is located in, cannot be deleted </td></tr>
    <tr><td class="paramname">states</td><td>Vector of vector of strings containing all the state names </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a2d9a39a3b099abb7b3e270dbedd682fd"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a2d9a39a3b099abb7b3e270dbedd682fd">&#9670;&nbsp;</a></span>minimize_()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::map&lt; const std::string, <a class="el" href="class_pair.html">Pair</a> * &gt; Utils::minimize_ </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_a.html">DFA</a> *&#160;</td>
          <td class="paramname"><em>dfa</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>"Activation" method for the TFA </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">dfa</td><td>Pointer to <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> where the TFA shall be executed on </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Map with pairs of a <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> used in the TFA with the name of the pair as key </dd></dl>

</div>
</div>
<a id="ab92c3a346f599ff6a780fea76a3dc7ff"></a>
<h2 class="memtitle"><span class="permalink"><a href="#ab92c3a346f599ff6a780fea76a3dc7ff">&#9670;&nbsp;</a></span>parse_set()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utils::parse_set </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse set into a vector of string - {p_1,p_2,p_3} --&gt; [p_1, p_2, p_3]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Set containing name of states </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of strings containing the name of states in set </dd></dl>

</div>
</div>
<a id="adcabc18dc019165483f4760ed0ccb9a8"></a>
<h2 class="memtitle"><span class="permalink"><a href="#adcabc18dc019165483f4760ed0ccb9a8">&#9670;&nbsp;</a></span>parse_set_space()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; std::string &gt; Utils::parse_set_space </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>x</em></td><td>)</td>
          <td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Parse set into a vector of string, but elements of set are spaced out with spaces - {p_1, p_2, p_3} --&gt; [p_1, p_2, p_3]. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">x</td><td>Set containing name of states with spaces </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of strings containing the name of states in set </dd></dl>

</div>
</div>
<a id="a091998c9a37b5e1e4f091ea405842760"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a091998c9a37b5e1e4f091ea405842760">&#9670;&nbsp;</a></span>replace_states()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">void Utils::replace_states </td>
          <td>(</td>
          <td class="paramtype"><a class="el" href="class_d_f_a.html">DFA</a> *&#160;</td>
          <td class="paramname"><em>old_dfa</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_a.html">DFA</a> &amp;&#160;</td>
          <td class="paramname"><em>minimized_dfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Replace states of old <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> by newly created states from minimized <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a>, old <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> is only used for recognizing the states. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">old_dfa</td><td>Pointer to "old" <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> </td></tr>
    <tr><td class="paramname">minimized_dfa</td><td>Reference to minimized <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> </td></tr>
  </table>
  </dd>
</dl>

</div>
</div>
<a id="a6870b41572144413b86ce3ac3b4bf78e"></a>
<h2 class="memtitle"><span class="permalink"><a href="#a6870b41572144413b86ce3ac3b4bf78e">&#9670;&nbsp;</a></span>state_closure()</h2>

<div class="memitem">
<div class="memproto">
      <table class="memname">
        <tr>
          <td class="memname">std::vector&lt; const <a class="el" href="class_state.html">State</a> * &gt; Utils::state_closure </td>
          <td>(</td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>set</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype">const std::string &amp;&#160;</td>
          <td class="paramname"><em>symbol</em>, </td>
        </tr>
        <tr>
          <td class="paramkey"></td>
          <td></td>
          <td class="paramtype"><a class="el" href="class_d_f_a.html">DFA</a> *&#160;</td>
          <td class="paramname"><em>dfa</em>&#160;</td>
        </tr>
        <tr>
          <td></td>
          <td>)</td>
          <td></td><td></td>
        </tr>
      </table>
</div><div class="memdoc">

<p>Get "closure" of a set, calculates all the transitions to states for a specific input-symbol for a set. </p>
<dl class="params"><dt>Parameters</dt><dd>
  <table class="params">
    <tr><td class="paramname">set</td><td>Set containing the name of states </td></tr>
    <tr><td class="paramname">symbol</td><td>The input-symbol which the closure needs to be calculated for </td></tr>
    <tr><td class="paramname">dfa</td><td>The <a class="el" href="class_d_f_a.html" title="Class implemented for DFA object.">DFA</a> / <a class="el" href="class_n_f_a.html" title="Class implemented for NFA that inherits of DFA, because NFA doesn&#39;t needs to be working for implement...">NFA</a> with the original states inside the set </td></tr>
  </table>
  </dd>
</dl>
<dl class="section return"><dt>Returns</dt><dd>Vector of states </dd></dl>

</div>
</div>
</div><!-- contents -->
<!-- start footer part -->
<hr class="footer"/><address class="footer"><small>
Generated by&#160;<a href="https://www.doxygen.org/index.html"><img class="footer" src="doxygen.svg" width="104" height="31" alt="doxygen"/></a> 1.9.1
</small></address>
</body>
</html>
